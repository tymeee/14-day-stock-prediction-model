# -*- coding: utf-8 -*-
"""streamlit_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1THAzBA7SGpVN_VRcZ2-7OIYeuOaEObg-
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from fastai.tabular.all import load_learner
import ta

# --- Indicator functions (same as yours, unchanged) ---
def compute_volatility_indicators(df):
    if len(df) < 14:
        for col in ['atr', 'bb_bbm', 'donchianwidth', 'keltnerwidth',
                    'ulcer', 'chaikin_volatility', 'historical_volatility',
                    'upper_band', 'lower_band']:
            df[col] = float('nan')
        return df
    atr = ta.volatility.AverageTrueRange(df['High'], df['Low'], df['Close'], window=14)
    df['atr'] = atr.average_true_range()
    bb = ta.volatility.BollingerBands(df['Close'], window=14)
    df['bb_bbm'] = bb.bollinger_mavg()
    dc = ta.volatility.DonchianChannel(df['High'], df['Low'], df['Close'], window=14)
    df['donchianwidth'] = dc.donchian_channel_wband()
    kc = ta.volatility.KeltnerChannel(df['High'], df['Low'], df['Close'], window=14)
    df['keltnerwidth'] = kc.keltner_channel_wband()
    ui = ta.volatility.UlcerIndex(df['Close'], window=14)
    df['ulcer'] = ui.ulcer_index()
    hl_range = df['High'] - df['Low']
    ema_hl = hl_range.ewm(span=10, adjust=False).mean()
    df['chaikin_volatility'] = ((ema_hl - ema_hl.shift(10)) / ema_hl.shift(10)) * 100
    log_return = np.log(df['Close'] / df['Close'].shift(1))
    df['historical_volatility'] = log_return.rolling(window=20).std() * np.sqrt(252)
    df['upper_band'] = df['High'].rolling(window=2).max()
    df['lower_band'] = df['Low'].rolling(window=2).min()
    return df

def compute_trend_indicators(df):
    if len(df) < 14:
        for col in ['macd', 'sma', 'ema', 'adx', 'psar-up', 'psar-down',
                    'ichimoku_a', 'ichimoku_b', 'supertrend', 'KST',
                    'plus_di', 'minus_di', 'VI-dff', 'VI+', 'VI-']:
            df[col] = float('nan')
        return df
    df['macd'] = ta.trend.MACD(df['Close']).macd()
    df['sma'] = ta.trend.SMAIndicator(df['Close'], window=14).sma_indicator()
    df['ema'] = ta.trend.EMAIndicator(df['Close'], window=14).ema_indicator()
    df['adx'] = ta.trend.ADXIndicator(df['High'], df['Low'], df['Close'], window=14).adx()
    df['psar-up'] = ta.trend.psar_up(df['High'], df['Low'], df['Close'])
    df['psar-down'] = ta.trend.psar_down(df['High'], df['Low'], df['Close'])
    ichi = ta.trend.IchimokuIndicator(df['High'], df['Low'])
    df['ichimoku_a'] = ichi.ichimoku_a()
    df['ichimoku_b'] = ichi.ichimoku_b()
    df['supertrend'] = ta.trend.stc(df['Close'])
    df['KST'] = ta.trend.KSTIndicator(df['Close']).kst()
    df['plus_di'] = ta.trend.adx_pos(df['High'], df['Low'], df['Close'])
    df['minus_di'] = ta.trend.adx_neg(df['High'], df['Low'], df['Close'])
    vortex = ta.trend.VortexIndicator(df['High'], df['Low'], df['Close'])
    df['VI-dff'] = vortex.vortex_indicator_diff()
    df['VI+'] = vortex.vortex_indicator_pos()
    df['VI-'] = vortex.vortex_indicator_neg()
    return df

def compute_momentum_indicators(df):
    df['rsi'] = ta.momentum.RSIIndicator(df['Close']).rsi()
    df['stochastic'] = ta.momentum.StochasticOscillator(df['High'], df['Low'], df['Close']).stoch()
    df['signal-stochastic'] = ta.momentum.StochasticOscillator(df['High'], df['Low'], df['Close']).stoch_signal()
    df['cci'] = ta.trend.CCIIndicator(df['High'], df['Low'], df['Close']).cci()
    df['williams%R'] = ta.momentum.WilliamsRIndicator(df['High'], df['Low'], df['Close']).williams_r()
    df['roc'] = ta.momentum.ROCIndicator(df['Close']).roc()
    df['awesome-oscillator'] = ta.momentum.AwesomeOscillatorIndicator(df['High'], df['Low']).awesome_oscillator()
    df['ultimate-oscillator'] = ta.momentum.UltimateOscillator(df['High'], df['Low'], df['Close']).ultimate_oscillator()
    df['trix'] = ta.trend.TRIXIndicator(df['Close']).trix()
    df['KAMA'] = ta.momentum.KAMAIndicator(df['Close'], window=10).kama()
    df['stochrsi'] = ta.momentum.StochRSIIndicator(df['Close']).stochrsi()
    return df

def add_technical_indicators(df):
    df = compute_volatility_indicators(df)
    df = compute_trend_indicators(df)
    df = compute_momentum_indicators(df)
    return df

# --- Load model ---
xgb_model = joblib.load('xgb_best_model_randomsearch.joblib')

# --- Streamlit UI ---
st.title("📈 14-Day Stock Return Predictor")
st.markdown("Upload CSV file with at least 14 days of OHLCV data (columns: Date, Open, High, Low, Close, Volume).")

uploaded_file = st.file_uploader("Upload your OHLCV CSV", type=["csv"])

if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)

    required_cols = {'Date', 'Open', 'High', 'Low', 'Close', 'Volume'}
    if not required_cols.issubset(df.columns):
        st.error(f"CSV must contain columns: {required_cols}")
    elif len(df) < 14:
        st.error("Please upload at least 14 days of data.")
    else:
        try:
            # --- Preprocess and compute indicators ---
            df['Date'] = pd.to_datetime(df['Date'])
            df = df.sort_values('Date').reset_index(drop=True)
            df = add_technical_indicators(df)
            df = df.dropna().reset_index(drop=True)

            # --- Extract sequence of last N days and flatten ---
            N = 12  # sequence length used in training
            if len(df) < N:
                st.error(f"Not enough rows with valid indicators. Need at least {N}, got {len(df)}.")
            else:
                # Select only indicator columns
                indicator_cols = df.columns.difference(['Date', 'Open', 'High', 'Low', 'Close', 'Volume'])
                latest_seq = df[indicator_cols].iloc[-N:].values.flatten()

                # Reshape to model input format
                x_input = np.array([latest_seq])

                # --- Make prediction ---
                xgb_pred = xgb_model.predict(x_input)[0]

                # Display
                st.success("✅ Prediction Complete")
                st.write(f"📊 **XGBoost**: `{xgb_pred:.4f}` % return in 14 days")

        except Exception as e:
            st.error(f"❌ Error processing data: {e}")
else:
    st.info("Please upload a CSV file to proceed.")